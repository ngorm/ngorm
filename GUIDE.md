# Definitive Guide to Object Relational Mapping with ngorm

Welcome! Thanks you for taking your time to check out on ngorm. This is a rather
TL:DR doc which will walk you through all things necessary to get started with
ngorm. Please check godoc reference too, there is a lot of good details there.


**NOTE**: The SQL shown in this doc is based on the ql dialect, which is SQL
like. You might see different results if you use other dialect. To have the same
result use ql database.

Enjoy!

## Table of contents

- [Getting started](#getting-started)
 - [Installation](#installation)
 - [Connecting to databases](#connecting-to-a-database)
 - [Migrations](#migrations)
 - [Create](#create)
 - [Query](#query)
 - [Preload](#preload)
 - [Update](#update)
 - [Delete](#delete)
 - [Associations](#associations)
    - [Belogs To](#belongs-to)
    - [Has one](#has-one)
    - [Has many](#has-many)
    - [Many to many](many-to-many)
    - [Polymorphism](#polymorphism)

- [Advanced](#advanced)
 - [Hooks](#hooks)
 - [Logging](#logging)
 - [SQL building](#sql-building)
 - [SQL execution](#sql-execution)
 - [Transactions](#transactions)

- [Primer on `database/sql` package](#primer-on-database-sql-package)


# Getting started

NGORM is a fork of gorm. I initially forked gorm for the purpose of improving
performance, after navigating through the whole code base it dawned to me that
there was no straight way to benchmark and any efforts won't be conveying the
truth about what is happening.

Queries are executed using `database/sql` package, majority of the time is spent
generating the queries from models. So there can be two places for
benchmarking.

First is the code that is responsible to take models and generate SQl. Second is the
code that uses `database/sql` to run the queries i.e measure how fast/efficient
are the generated queries.

The second part is too broad and vague, and might have different outcomes based
on the nature of the database. So the focus of ngorm is to make sure all the
cases are addressed, in a way that  the library generates the best possible
queries for the supported databases.

## Installation

	go get -u github.com/gernest/ngorm

## Connecting to a database

NGORM uses a similar API as the one used by `database/sql` package to connect
to a database.

```go
package main

import (
	"log"

	// You must import the driver for the database you wish to connect to. In
	// this example I am using the ql driver, this should work similar for the
	// other supported databases.
	_ "github.com/cznic/ql/driver"
	"github.com/gernest/ngorm"
)

func main() {

	// The frist armunet is the dialect or the name of the database driver that
	// you wish to to connect to, the second argument is connection information
	// please check the appropriate driver for more information on the arguments
	// that are passed to database/sql Open.
	db, err := ngorm.Open("ql-mem", "est.db")
	if err != nil {
		log.Fatal(err)
	}

	// Do something with db
}
```

The return `ngorm.DB` instance is safe. It is a good idea to have only one
instance of this object throughout your application life cycle. Make it a global
or pass it in context.


# Migrations
NGORM offers auto migrations. `DB.Automigrate` handless creation of the database
table if the table doesn't exist yet. It also handles changes in the fields.

Bonus point , you can use `DB.AtomirateSQL` to see the SQL query that will be
executed without executing anything.

Given you have the following model

```go
type Foo struct {
	ID    int
	Stuff string
}
```

### Create Table

	db.CreateTable(&Foo{})

You can view the sql generated by the above method without executing the query.

	sql, err := db.CreateTableSQL(&Foo{})
	if err != nil {
		tog.Fatal(err)
	}
	fmt.Println(sql.Q)

Will print

```sql
BEGIN TRANSACTION; 
	CREATE TABLE foos (id int,stuff string ) ;
COMMIT;
```


### Drop Table

	db.DropTable(&Foo{})


You can view the sql generated by the above method without executing the query.

```go

	sql, err := db.DropTableSQL(&Foo{}, &User{})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(sql.Q)
```

Will print

```sql

BEGIN TRANSACTION; 
	DROP TABLE foos;
	DROP TABLE users;
COMMIT;
```

## Automigrate

Given that you have the following models.



```go

type User struct {
	ID                int64
	Age               int64
	UserNum           Num
	Name              string `sql:"size:255"`
	Email             string
	Birthday          *time.Time    // Time
	CreatedAt         time.Time     // CreatedAt: Time of record is created, will be insert automatically
	UpdatedAt         time.Time     // UpdatedAt: Time of record is updated, will be updated automatically
	Emails            []Email       // Embedded structs
	BillingAddress    Address       // Embedded struct
	BillingAddressID  sql.NullInt64 // Embedded struct's foreign key
	ShippingAddress   Address       // Embedded struct
	ShippingAddressID int64         // Embedded struct's foreign key
	CreditCard        CreditCard
	Latitude          float64
	Languages         []Language `gorm:"many2many:user_languages;"`
	CompanyID         *int
	Company           Company
	Role
	PasswordHash      []byte
	Sequence          uint                  `gorm:"AUTO_INCREMENT"`
	IgnoreMe          int64                 `sql:"-"`
	IgnoreStringSlice []string              `sql:"-"`
	Ignored           struct{ Name string } `sql:"-"`
	IgnoredPointer    *User                 `sql:"-"`
}


type CreditCard struct {
	ID        int8
	Number    string
	UserID    sql.NullInt64
	CreatedAt time.Time `sql:"not null"`
	UpdatedAt time.Time
	DeletedAt *time.Time
}

type Email struct {
	ID        int16
	UserID    int
	Email     string `sql:"type:varchar(100);"`
	CreatedAt time.Time
	UpdatedAt time.Time
}

type Address struct {
	ID        int
	Address1  string
	Address2  string
	Post      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time
}

type Language struct {
	model.Model
	Name  string
	Users []User `gorm:"many2many:user_languages;"`
}

type Company struct {
	ID    int64
	Name  string
	Owner *User `sql:"-"`
}

```

We can observe what SQL is generated when we run automigration on these models.

```go
	sql, err := db.AutomigrateSQL(
		&User{},
		&Email{},
		&Language{},
		&Company{},
		&CreditCard{},
		&Address{},
	)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(sql.Q)
```

Will print

```sql

BEGIN TRANSACTION;
	CREATE TABLE users (id int64,age int64,user_num int64,name string,email string,birthday time,created_at time,updated_at time,billing_address_id int64,shipping_address_id int64,latitude float64,company_id int,role string,password_hash blob,sequence uint ) ;
	CREATE TABLE user_languages (user_id uint,language_id uint ) ;
	CREATE TABLE emails (id int16,user_id int,email string,created_at time,updated_at time ) ;
	CREATE TABLE languages (id uint,created_at time,updated_at time,deleted_at time,name string ) ;
	CREATE INDEX idx_languages_deleted_at ON languages(deleted_at);
	CREATE TABLE companies (id int64,name string ) ;
	CREATE TABLE credit_cards (id int8,number string,user_id int64,created_at time NOT NULL,updated_at time,deleted_at time ) ;
	CREATE TABLE addresses (id int,address1 string,address2 string,post string,created_at time,updated_at time,deleted_at time ) ;
COMMIT;
```

To run the Actual migration just do this
```go
	dB.Automigrate{&User{},&Email{},&Language{},&Company{},&CreditCard{},&Address{}}
```



## Create

Given you have models

```go
		type Bar struct {
			ID  int64
			Say string
		}
```

You can Observe the Generates SQL which is generated when creating the new Bar
record like this.

```go
sql,err:=db.CreateSQL(&Bar{Say:"hello"})
if err!=nil{
  log.Fatal(err)
}
fmt.Println(sql.Q)
fmt.Printf("$1=%v", sql.Args[0])
```

The above snippet will print

```sql

	BEGIN TRANSACTION;
		INSERT INTO bars (say) VALUES ($1);
	COMMIT;
	$1=hello

```

And, creating a new record is as simple as

	db.Create(&Ba{Say:"hello"})

